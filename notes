;; -*- mode: outline; outline-regexp: " *[-\+]"; indent-tabs-mode: nil; fill-column: 120 -*-

^c^d hide subtree
^c^s show subtree

Strict Dump Performance
JSON::Ext.dump 20000 times in 0.173 seconds or 115493.546 dump/sec.
Oj:strict.dump 20000 times in 0.050 seconds or 401475.753 dump/sec.

Summary:
   System  time (secs)  rate (ops/sec)
   ---------  -----------  --------------
   Oj:strict       0.050      401475.753
   JSON::Ext       0.173      115493.546

Comparison Matrix
(performance factor, 2.0 means row is twice as fast as column)
           Oj:strict  JSON::Ext
           ---------  ---------  ---------
           Oj:strict       1.00       3.48
           JSON::Ext       0.29       1.00
           
- refactor
 - what happened to obj mode loading time?

 - plan
  - compat
   - recursive calls for hash and arrays
   - dump, generate, JSON, to_json the same except for Infinity (maybe)
    - dump is different - "Infinity" instead of exception
   - differs for array and hash
    - hash and array and other core types like string to_json monkey patch ignored
    - json gem breaks
     - hash.to_json "foo"
      - dump {"x"=>1} - ignored
      - dump {"x"=>Rational(2,9)} - {"x":foo} - since rational creates a hash and calls to_json
      - to_json - returns foo
      - JSON, generate, and dump all the same
      - [{}] as expected, not foo
   - json/add/core and other adds
    - override with Oj.add_to_json for each type, core
  - rules
   - for core types, always use core (similar to json gem)
   - for non core, if special and special flag set then use the special encodeing
    - keep a map, set function on entry if Oj.add_to_json(class) matches
   - if to_json use that
   - else to_s
   - if dump and nan, or infinity then special treatment and print string
 
Oj ignores Hash, Array and core type overrides and monkey patches (differs from json gem)

Oj.add_core() - same as require json/add/core but with fast impl if not using to_json directly
 - to_json overrides ignores unless Oj.remove_core
 - Oj.add_to_json(class) and Oj.remove_to_json(class)
  - 



  - address how to handle the requires like 'json/add/core'
   - can a check be made for whether the to_json is the oj one or something else?
    - maybe not
   - have to detect non-oj to_jsons in order to optimizes

  - doc for modes
   - web page?
   - 
  - object mode
   - move tests
   - parse down dump_object

  - rails mode

  - custom mode
  
  - reorg tests
   - isolated rails stuff
    - only need to verify JSON methods have beed defined and not overridden
    - really a mimic tests
    - can rails tests not be run for 1.9.3?


  - create dump_custom, copy from compat

  - have rails use compat funcs
  
 - add rails mode
 - add use_to_hash option
 - custom mode for using all the options

 - hook up circular for strict and compat but without adding the id
 
  

- rail compat
 - fix struct
 - consider
  - detecting active classes (how expensive is it) and calling as_json
  - something like odd but with a faster lookup that has specially build active dumpers

 + Regexp
 + StringSpecial
  - new friendly mode for XSS and hibit - hixss
 + Struct
 + Rational
 + Enumerable

 - add circular check for compat and just stop on compat and don't follow

 - Process::Status
 - ActiveSupport::TimeWithZone
 - ActiveModel::Errors
 - ActiveSupport::Multibyte::Chars
 - ActiveRecord::Relation

 - make regexp an odd

 - how about a const for rails options (separate from mimic or maybe the same set)
  - or a function to set options to rails

- debug
 - instrument for parsing floats/bigdecimal
  - branch

 - option to allow invalid unicode through
 - unit tests for 32 bit - test_float_parse
  - look at RUBY_PLATFORM maybe?
 - look at env var for OJ_DEBUG when doing ruby extconf.rb
 - add printf for keys spots in parse and dump
 
- invalid character option
 - don't check options
  - replace with best attempt such as \ud83d => \xED\xA0\xBD
  - that would be the normal replacement
 - allow_invalid_unicode

- streaming parser for scp and saj

---------------------------
Tried a separate thread for the parser and the results were poor. The parsing is
10% to 15% of the total so splitting ruby calls and c does not help much and the
overhead of swapping data was too high. It was not possible to split ruby calls
into both threads due to not getting a lock on the ruby environment for object
creation.
